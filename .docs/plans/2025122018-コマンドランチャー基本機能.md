# コーディング計画: コマンドランチャー基本機能

作成日時: 2025-12-20 18:47
参照アイディアファイル: `01-アプリの実装開始.md`

## 実装する機能

- バックグラウンド常駐し、グローバルホットキーで呼び出せるランチャー
- フルスクリーン動作中はホットキーを無効化できる
- ホットキー無効化中はタスクトレイのアイコン表示を切り替える
- 設定ファイル `~/.config/<APP_NAME>/setting.yaml` に定義したコマンドを実行できる
- 環境変数ファイル `~/.config/<APP_NAME>/env.yaml` を読み込み、コマンド実行時に渡せる

## 機能の詳細な仕様

### 常駐と起動

- アプリ起動後は常駐モードで動作する
- UI を表示しない状態がデフォルト（ホットキーで表示をトグル）

### ホットキー

- 1 つのグローバルホットキーで UI の表示/非表示を切り替える
- フルスクリーン判定が真の場合はホットキーイベントを無視する

### フルスクリーン判定

- アクティブウィンドウが画面全体を占有している場合を「フルスクリーン」とみなす
- 最小要件として以下を満たすこと
  - 現在の前面ウィンドウの矩形を取得する
  - その矩形がモニタの作業領域またはモニタ領域と十分に一致しているかで判定する
- 判定の詳細（閾値、作業領域か全領域か）は実装段階で選定し、設定値として将来外出し可能な形にする

### タスクトレイ

- 常駐中はタスクトレイにアイコンを表示する
- ホットキー有効/無効状態が視覚的に分かるようにアイコンを切り替える
- 最小要件として以下を満たすこと
  - 左クリックまたはダブルクリックで UI 表示をトグルできる
  - 右クリックのコンテキストメニューから終了できる

### 設定ファイル

- 参照パス
  - 設定: `~/.config/<APP_NAME>/setting.yaml`
  - 環境変数: `~/.config/<APP_NAME>/env.yaml`
- 期待する内容
  - setting.yaml に実行可能なコマンド一覧を定義できる
  - env.yaml に環境変数（キーと値）を定義できる
- 失敗時の扱い
  - 設定が読めない場合はエラーをログに出し、UI またはトレイメニューから通知できるようにする（初回はログ出力のみでも可）

### コマンド実行

- `std::process::Command` を用いてコマンドを起動する
- env.yaml の内容を環境変数としてプロセスに渡す
- setting.yaml 側が任意の環境変数参照を必要とする場合は、まずは「プロセスに env を渡す」のみを必須要件とする

## 技術的な実装方針

- OS 連携（Win32 API 操作）
  - `windows`（windows-rs）を利用して前面ウィンドウやモニタ情報の取得を行う
- グローバルホットキー
  - crate `global-hotkey` を第一候補として評価する
  - 期待を満たせない場合は Windows API での実装に切り替え可能な層（trait）を用意する
- タスクトレイ
  - crate は `tray-icon` を第一候補とし、実装が難しい箇所のみ Windows API への切り替え余地を残す
- UI
  - 最小の UI（コマンド一覧の選択と実行）を最初に作る
  - 候補は `egui`（`eframe`）または `slint` だが、まずは既存のプロジェクト方針や依存を増やさない観点で `egui` を優先して評価する
- 設定ファイル
  - 仕様は YAML なので `serde` + `serde_yaml` を使用する
  - 設定構造体を定義し、読み込みとバリデーションを分離する
- ログ
  - 最小要件として `tracing` + `tracing-subscriber` でファイルまたは標準出力にログを出せるようにする

## 実装手順

### 1. 設定ディレクトリと設定読み込みの骨格

- `<APP_NAME>` を Cargo の package 名または定数で決める
- `~/.config/<APP_NAME>/` 配下を参照するユーティリティを用意する
- `setting.yaml` と `env.yaml` の読み込みとデシリアライズを実装する
- ここまでで `cargo build` が通る

### 2. コマンド実行機構

- 設定から選んだコマンドを `std::process::Command` で起動できるようにする
- env.yaml の内容を子プロセスに環境変数として渡す
- ここまでで最小の手動テスト（固定コマンド実行）が可能

### 3. 常駐とタスクトレイ

- タスクトレイのアイコンを表示できるようにする
- トレイメニューから終了できるようにする
- UI 表示のトグル（最初はダミーのウィンドウでも可）
- ここまでで常駐の動作確認が可能

### 4. グローバルホットキー

- `global-hotkey` を導入し、ホットキーで UI 表示/非表示を切り替える
- ホットキーの登録失敗時はログを出してアプリを継続する（終了はしない）
- ここまででホットキーの動作確認が可能

### 5. フルスクリーン検知とホットキー無効化

- 前面ウィンドウとモニタ領域の取得を実装する
- フルスクリーン判定が真のときホットキー処理を無視する
- ホットキー無効状態に応じてトレイアイコンを切り替える
- ここまでで仕様の主要要件を満たす

### 6. 最小 UI（コマンド選択と実行）

- 設定からコマンド一覧を読み込み表示する
- 選択したコマンドを実行できる
- エラーは UI に表示する（初回はログでも可）

## 分割プランが必要になった場合

- UI 選定やトレイ実装の難易度が高い場合は、以下の観点で段階的に分割する
- まずは「ホットキー + トレイ + フルスクリーン無効化」を先に固める
- 次に「設定ファイル + コマンド実行 + UI」の磨き込みを行う
