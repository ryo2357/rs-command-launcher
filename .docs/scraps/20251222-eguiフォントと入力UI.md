# 2025-12-22 egui フォントと入力 UI

このスクラップは会話内容を日時順にそのまま記録したものです（重複は削除していません）。

---

### ユーザー:

egui について調べたい

- 日本語の表示が文字化けするのでその対策方法を知りたい
- 半透明の文字入力 UI だけを表示したい。どのように実装すればいい？
- 1 文字入力する度に候補を入力枠のしたに表示したい。どのような実装をすればいい？

### アシスタント:

（日本語で回答。フォントをバンドルして `cc.egui_ctx.set_fonts` で設定する方法、透明な入力 UI を作るための `NativeOptions` / フレーム設定、入力ごとのサジェスト表示の実装例を提示。）

提供した主な内容（抜粋）:

- 日本語対応フォントをアプリに登録すること（例: Noto Sans JP / IPAex）。`include_bytes!` でフォントを埋め込み、`CreationContext` の `cc.egui_ctx.set_fonts()` を呼ぶ。

- 半透明の入力 UI だけを表示するには、OS ウィンドウ側で透過・枠無しにする設定（`NativeOptions` の透過やデコレーション無効化等）と、egui 側で `CentralPanel` を透明にし、入力欄だけ `Frame` を半透明で描画する。

- 1 文字入力ごとに候補を出すには、`TextEdit` の `response.changed()` 等で入力変化を検知して候補をフィルタリングし、`ScrollArea` 等で入力欄直下に描画。キー操作（↑↓）で選択、Enter で確定の状態を持たせる。

サンプルコード（フォント埋め込み、透明フレーム、簡易サジェストの抜粋）を提示。

---

### ユーザー:

（`src/ui.rs` ファイルを添付。現在の実装を提示）

添付された `src/ui.rs` の内容（抜粋）:

```rust
use eframe::egui;
use log::{error, info};

use crate::{config, paths, runner};

pub fn run() -> anyhow::Result<()> {
    let native_options = eframe::NativeOptions::default();

    eframe::run_native(
        "command-launcher",
        native_options,
        Box::new(|_cc| Ok(Box::new(LauncherApp::new()?))),
    )
    .map_err(|e| anyhow::Error::msg(format!("UI を起動できません: {e:?}")))?;

    Ok(())
}

struct LauncherApp {
    command_input: String,
    status: String,
    settings: Option<config::Settings>,
    env_vars: Option<config::EnvVars>,
}

impl LauncherApp {
    fn new() -> anyhow::Result<Self> {
        let (settings, env_vars, status) = match load_config() {
            Ok((settings, env_vars)) => {
                let status = format!("設定を読み込みました: {} 件のコマンド", settings.commands.len());
                (Some(settings), Some(env_vars), status)
            }
            Err(e) => {
                error!("設定読み込みに失敗しました: {e:?}");
                (None, None, format!("設定読み込みに失敗しました: {e:#}"))
            }
        };

        Ok(Self {
            command_input: String::new(),
            status,
            settings,
            env_vars,
        })
    }

    fn try_run_command(&mut self) {
        let input = self.command_input.trim();
        if input.is_empty() {
            self.status = "コマンド名を入力してください".to_string();
            return;
        }

        let Some(settings) = self.settings.as_ref() else {
            self.status = "設定が読み込まれていません".to_string();
            return;
        };
        let Some(env_vars) = self.env_vars.as_ref() else {
            self.status = "環境変数が読み込まれていません".to_string();
            return;
        };

        let Some(command) = settings.commands.iter().find(|c| c.name == input) else {
            self.status = format!("指定されたコマンドが見つかりません: {input}");
            return;
        };

        match runner::spawn_command(command, env_vars) {
            Ok(_child) => {
                info!("{:?}を起動しました", command.name);
                self.status = format!("起動しました: {}", command.name);
                self.command_input.clear();
            }
            Err(e) => {
                error!("起動に失敗しました: {e:?}");
                self.status = format!("起動に失敗しました: {e:#}");
            }
        }
    }
}

impl eframe::App for LauncherApp {
    fn update(&mut self, ctx: &egui::Context, _frame: &mut eframe::Frame) {
        egui::CentralPanel::default().show(ctx, |ui| {
            ui.label("コマンド名を入力して Enter で実行");

            let response = ui.add(
                egui::TextEdit::singleline(&mut self.command_input)
                    .hint_text("CommandSpec.name")
                    .desired_width(f32::INFINITY),
            );

            if response.has_focus() && ui.input(|i| i.key_pressed(egui::Key::Enter)) {
                self.try_run_command();
            }

            ui.separator();
            ui.label(&self.status);
        });
    }
}

fn load_config() -> anyhow::Result<(config::Settings, config::EnvVars)> {
    let settings_path = paths::settings_path()?;
    let env_path = paths::env_path()?;

    let settings = config::load_settings(&settings_path)?;
    let env_vars = config::load_env_vars(&env_path)?;

    Ok((settings, env_vars))
}
```

---

### ユーザー:

1 について asset をバンドルするのではなく Windows のフォントを使うことはできる？

またアプリの動作的にはどちらが有利？

---

### アシスタント:

（日本語で回答。要点）

- Windows のフォントファイル（`C:\Windows\Fonts\...`）を `std::fs::read` で読み、`egui::FontData::from_owned(bytes)` を使って登録することは可能。ただし `.ttc`（TrueType Collection）に注意。`

- 実装例（複数候補を試す、失敗したらログを出してフォールバック）：

```rust
use std::fs;

fn try_set_windows_japanese_font(ctx: &egui::Context) -> anyhow::Result<()> {
    let candidates = [
        r"C:\Windows\Fonts\YuGothM.ttc",
        r"C:\Windows\Fonts\meiryo.ttc",
        r"C:\Windows\Fonts\msgothic.ttc",
    ];

    let mut last_err: Option<anyhow::Error> = None;

    for path in candidates {
        match fs::read(path) {
            Ok(bytes) => {
                let mut fonts = egui::FontDefinitions::default();
                fonts.font_data.insert("jp".to_owned(), egui::FontData::from_owned(bytes));

                fonts
                    .families
                    .entry(egui::FontFamily::Proportional)
                    .or_default()
                    .insert(0, "jp".to_owned());
                fonts
                    .families
                    .entry(egui::FontFamily::Monospace)
                    .or_default()
                    .insert(0, "jp".to_owned());

                ctx.set_fonts(fonts);
                log::info!("Windows フォントを使用します: {}", path);
                return Ok(());
            }
            Err(e) => {
                last_err = Some(anyhow::Error::new(e).context(format!("font read failed: {path}")));
            }
        }
    }

    Err(last_err.unwrap_or_else(|| anyhow::anyhow!("利用可能なフォント候補がありません")))
}
```

- バンドル（同梱）の利点: 確実性、配布の容易さ。欠点: サイズ増、ライセンスチェック。
- システムフォント利用の利点: 配布サイズが小さい、OS の見た目に寄せやすい。欠点: 環境差、`.ttc` の扱いの問題、パスの違い。

---

### ユーザー:

Follow instructions in `scrap.prompt.md`.

---

## （このファイルは会話をそのまま時系列で保存したスクラップです。追加で記録してほしい項目や修正があれば教えてください。）

## 追記（半透明 UI の実装上の注意）

- `eframe::NativeOptions` でウィンドウ透過や枠無し、最前面などを設定し、egui 側では `CentralPanel` に透明フレームを指定して入力部だけ半透明の `Frame` を描く組み合わせが簡単で実用的です。
- 例: `native_options.transparent = true; native_options.decorated = false; native_options.always_on_top = true;`
- ドラッグで「入力ウィンドウ」を動かしたり、完全なクリックスルー（クリックを下層アプリに透過）を行いたい場合は、プラットフォーム固有の window handle を操作する必要があります（Windows だと Win32 の追加フラグ等）。
- まずは eframe/egui の組み合わせで見た目と基本機能を確認し、必要なら OS 固有の拡張実装を追加するのが現実的です。

## 追記（サジェスト/補完の実装上の留意点）

- 入力変化で候補を即時再計算する実装は簡単で反応も良いですが、入力が高速だと無駄な再計算が多くなるため短いデバウンス（数十 ms）を入れるとよいです。
- 候補は表示数を制限（例: 10 件）し、スコアリング（fuzzy）を導入すると UX が向上します。`fuzzy-matcher` などのクレートを検討してください。
- 見た目は `egui::Area` を使って `response.rect` の下にドロップダウン表示すると自然に見えます。選択はクリック/↑↓/Enter/ESC で操作できるように状態を持たせます。

簡易的な実装例（抜粋）:

```rust
// 状態を持つ
struct LauncherApp {
    command_input: String,
    suggestions: Vec<String>,
    selected_suggest: usize,
    // ...既存のフィールド...
}

// 候補更新（単純な contains ベース）
fn update_suggestions(&mut self) {
    let q = self.command_input.trim().to_lowercase();
    if q.is_empty() {
        self.suggestions.clear();
    } else if let Some(settings) = &self.settings {
        self.suggestions = settings
            .commands
            .iter()
            .map(|c| c.name.clone())
            .filter(|n| n.to_lowercase().contains(&q))
            .take(10)
            .collect();
        self.selected_suggest = 0;
    }
}

// update 内で: 変更検知・キーボード処理・Area によるドロップダウン描画
if response.changed() { self.update_suggestions(); }
ui.input(|i| { /* ArrowUp/Down/Enter/Escape 処理 */ });
if !self.suggestions.is_empty() {
    let pos = egui::pos2(response.rect.left(), response.rect.bottom());
    egui::Area::new("suggestions").fixed_pos(pos).show(ctx, |ui| {
        egui::Frame::popup(ui.style()).show(ui, |ui| {
            for (i, s) in self.suggestions.iter().enumerate() {
                if ui.selectable_label(i==self.selected_suggest, s).clicked() {
                    self.command_input = s.clone();
                    self.suggestions.clear();
                    self.try_run_command();
                }
            }
        });
    });
}
```

- 最後に: 実装はまず最小限（クリックで選択できる一覧）を作り、キーボード操作・デバウンス・曖昧検索などを段階的に追加するのがおすすめです。
