# 2025-12-23: netsh と UAC, クリップボードに関する会話ログ

- ユーザー: std::process::Command;について

  - クリップボードに文字列を転送するコマンドはある？
  - netsh などの管理者権限が必要な処理を実行したい場合どうすればいい？

- アシスタント: 回答（要旨）

  - std::process::Command 自体にクリップボード専用 API はない。Windows の場合 `clip.exe` を使うのが定番で、Rust からは `Command::new("clip.exe")` を起動して stdin に書き込む方法が推奨される。
  - 管理者権限が必要な場合の選択肢:
    - アプリ自体を管理者として実行する（簡単）。
    - UAC プロンプト付きで昇格起動する（Windows: `Start-Process -Verb RunAs` を使う、ただし UAC 同意が必要で標準入出力の受け渡しが難しい）。
    - 権限が必要な処理を管理者権限のサービスやタスクに分離して IPC で依頼する（堅牢）。
  - 実装上の注意: ログは `log` クレートを使用、ログ初期化は `main` で行う（プロジェクト方針）。

- ユーザー: UAC プロンプト付きで昇格起動で問題ない。Windows の場合、std::process::Command は powershell で実行されている？

- アシスタント: 回答（要旨）

  - いいえ。`std::process::Command` は既定でシェル（PowerShell/cmd）を経由しない。Windows では `CreateProcessW` 相当で直接プロセスを起動する。
  - UAC を出して昇格したい場合は、PowerShell の `Start-Process -Verb RunAs` を `Command` で呼ぶのが定番。注意点として UAC の同意が必要、標準入出力の受け渡しは難しいケースがある。

- アシスタント: 提案した `spawn_command_elevated` の例コード（要旨）

```rust
use std::process::{Child, Command};
use anyhow::Context;
use log::debug;
use crate::model::commands::CommandSpec;

pub fn spawn_command(command: &CommandSpec) -> anyhow::Result<Child> {
    let mut cmd = Command::new(command.program());
    cmd.args(command.args());
    debug!("spawn: program={} args={:?}", command.program(), command.args());
    cmd.spawn()
        .with_context(|| format!("コマンドを起動できません: {}", command.name()))
}

fn escape_pwsh_single_quote(s: &str) -> String {
    s.replace('\'', "''")
}

pub fn spawn_command_elevated(command: &CommandSpec) -> anyhow::Result<Child> {
    let file_path = escape_pwsh_single_quote(command.program());
    let arg_list = command
        .args()
        .iter()
        .map(|a| format!("'{}'", escape_pwsh_single_quote(a)))
        .collect::<Vec<_>>()
        .join(", ");

    let script = format!(
        "$ErrorActionPreference='Stop'; \
         $p = Start-Process -FilePath '{file_path}' -ArgumentList @({arg_list}) -Verb RunAs -PassThru -Wait; \
         exit $p.ExitCode;"
    );

    debug!(
        "spawn elevated: program={} args={:?}",
        command.program(),
        command.args()
    );

    Command::new("powershell.exe")
        .args([
            "-NoProfile",
            "-NonInteractive",
            "-ExecutionPolicy",
            "Bypass",
            "-Command",
            &script,
        ])
        .spawn()
        .with_context(|| format!("管理者としてコマンドを起動できません: {}", command.name()))
}
```

- 注意点（そのまま記録）

  - `spawn_command_elevated` は powershell のプロセスを返す。`-Wait` を付けることで `Child::wait()` は昇格先の終了に同期できる。
  - UAC が拒否されると起動失敗になる。
  - 標準入出力を同じ端末にパイプするのは難しい場合がある（昇格は別プロセス境界になるため）。

- ユーザー: netsh 以下のコマンドはどこで処理される？

- アシスタント: 回答（要旨）

  - リポジトリ内では `src/runner.rs` の `spawn_command()` が `Command::new(command.program())` と `cmd.args(command.args())` で `netsh` を起動している。アプリは `netsh` のサブコマンド内容を解釈していない（文字列を渡しているだけ）。
  - Windows 側では起動された `netsh.exe` が引数をパースし、必要なネットワーク設定 API/サービスを呼び出して処理する。
  - UAC 昇格で起動した場合も、実際に引数を解釈して処理するのは昇格後の `netsh.exe` である。

- ユーザー: `spawn_command_elevated` で `netsh` を実行したい場合の `CommandSpec` はどうなる？

- アシスタント: 回答（要旨）
  - `CommandSpec` は `program()` と `args()` をそのまま使うため、`program` を "netsh" にして、`args` を netsh のサブコマンドをトークンごとに分割した `Vec<String>` にする。

例:

```rust
let spec = CommandSpec::new(
    "set-ip",
    "netsh",
    vec![
        "interface".into(),
        "ip".into(),
        "set".into(),
        "address".into(),
        "name=Ethernet".into(),
        "static".into(),
        "192.168.0.10".into(),
        "255.255.255.0".into(),
        "192.168.0.1".into(),
    ],
);
```

- ユーザーが提供した `src/model/commands.rs` の現状ソース（抜粋）

```rust
use serde::Deserialize;
use std::collections::HashSet;
use std::collections::BTreeMap;

pub type EnvVars = BTreeMap<String, String>;

#[derive(Debug, Clone, Deserialize)]
pub struct CommandSpec {
    name: String,
    program: String,
    #[serde(default)]
    args: Vec<String>,
}

impl CommandSpec {
    pub fn name(&self) -> &str { &self.name }
    pub fn program(&self) -> &str { &self.program }
    pub fn args(&self) -> &Vec<String> { &self.args }
}

// 省略: Commands の実装や expand_vars 等のユーティリティ
```

- 補足（提案や選択肢のメリット/デメリット）

  - アプリ全体を管理者で実行する: 簡単に admin 権限で netsh を実行できるが、アプリ全体が高権限で動くためリスクがある。
  - `Start-Process -Verb RunAs` を使う: UAC プロンプトで昇格できるが、UAC の同意が必要で I/O の取り扱いに制約がある。
  - 管理者サービスへ委譲する: 設計が複雑だが、安全かつ非対話環境でも実行可能。

- ユーザーの最後の指示: "Follow instructions in [scrap.prompt.md]" → このファイルはその指示に従って作成したスクラップである。

- ユーザー: `CommandSpec` に `#[serde(default)] elevated: bool` を追加して `true` のとき `spawn_command_elevated` を呼ぶ実装であれば、既存の設定ファイルのまま機能を追加できるか？

- アシスタント: 回答（要旨）

  - はい。`#[serde(default)]` を付けた `elevated: bool` を追加し、`spawn_command` の中で `if command.elevated() { spawn_command_elevated(command) } else { ... }` と分岐すれば、既存設定ファイルはそのまま動作します（フィールドが欠落している場合は `false` が代入されるため）。
  - 実装例（最小差分）:

```rust
#[derive(Debug, Clone, Deserialize)]
pub struct CommandSpec {
    name: String,
    program: String,
    #[serde(default)]
    args: Vec<String>,

    #[serde(default)]
    elevated: bool,
}

impl CommandSpec {
    // ...既存メソッド...
    pub fn elevated(&self) -> bool {
        self.elevated
    }
}

pub fn spawn_command(command: &CommandSpec) -> anyhow::Result<Child> {
    if command.elevated() {
        spawn_command_elevated(command)
    } else {
        let mut cmd = Command::new(command.program());
        cmd.args(command.args());
        cmd.spawn()
            .with_context(|| format!("コマンドを起動できません: {}", command.name()))
    }
}
```

- 注意点:
  - `#[serde(default)]` の `bool` は欠落時に `false` になるため後方互換性が保たれる。
  - `null` が入力されるとデシリアライズエラーになる点に注意（必要なら `Option<bool>` やカスタムデシリアライザで対応）。
  - テストとドキュメントの追加を推奨する（デシリアライズの単体テスト、設定例の更新、UAC に関する動作確認）。

END
