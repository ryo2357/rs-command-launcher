# タスクトレイ機能

## 概要

ホットキーでランチャーを非表示（`hide`）にしてもアプリが起動していることをタスクトレイで確認でき、非表示時にタスクトレイからアプリを終了できるようにする。実装案として `tray-icon` を使い、トレイのメニュー（表示/非表示/終了）から `eframe + egui` 側へコマンド送信して `ShowWindow` と `ViewportCommand::Close` で制御する。

## 要件

- ホットキーでランチャーを非表示にした場合でも、アプリが起動していることを確認できる（タスクトレイ常駐）。
- 非表示時にタスクトレイからアプリを終了できる。

## 前提（既存構成）

- UI: `eframe + egui`
- 非表示は `hide`（プロセスは落とさずウィンドウだけ隠す）
- ログ運用ルール: `println!` は使わず `log` を使い、初期化は `main` で行う。
- `HWND` は `raw_window_handle` 経由で取得している。

## 依存関係案（Cargo.toml）

- `tray-icon`（タスクトレイ）
- `icon`（RGBA からアイコン生成）
- `image`（PNG 読み込み。例として `png` feature）
- `log` / `env_logger`

例:

```toml
[dependencies]
log = "0.4"
env_logger = "0.11"
tray-icon = "0.19"
icon = "0.3"
image = { version = "0.25", default-features = false, features = ["png"] }
```

## トレイアイコン PNG サイズ

- 1 枚だけ用意するなら `32x32` の透過 PNG が無難。
- より綺麗にしたい場合の候補: `16x16 / 32x32 / 64x64`。
- 余白少なめで中央寄せの絵柄が推奨。

## タスクトレイ側の設計（TaskTray）

- 起動時にトレイを生成し、アプリが非表示でもトレイが残るようにする。
- メニュー項目:
  - `表示`
  - `非表示`
  - `終了`
- トレイ側イベントを受けたら上位へコマンドを送る。

コマンド列挙:

```rust
pub enum TrayCommand {
    Show,
    Hide,
    Quit,
}
```

通信:

- `std::sync::mpsc::channel::<TrayCommand>()` を使い、`Receiver<TrayCommand>` を `eframe` 側へ渡す。

重要な注意点:

- `TaskTray`（および `TrayIcon`）が `drop` されるとトレイアイコンが消えるので、`App` 側で保持する。
- `tray-icon` のイベント型や API はバージョンで差が出やすいので、`Cargo.lock` の実際のバージョンに合わせてイベント受信部分を調整する前提。
- `include_bytes!` で `assets/tray.png` を埋め込んで `image` で RGBA 化し、`icon::Icon::from_rgba` で作る案。

## eframe/egui 側の受信・表示/非表示・終了処理

### 受信（update 内）

- `LauncherApp` に `tray_rx: Receiver<TrayCommand>` を持たせる。
- `update()` 冒頭で `while let Ok(cmd) = tray_rx.try_recv()` で取り切る。

### 表示/非表示（Win32）

- `HWND` がある前提で `ShowWindow` を呼ぶ。
- 表示時は前面化として `SetForegroundWindow` も呼ぶ案。

例:

```rust
use windows_sys::Win32::UI::WindowsAndMessaging::{ShowWindow, SetForegroundWindow, SW_HIDE, SW_SHOW};

unsafe {
    ShowWindow(hwnd, SW_SHOW);
    SetForegroundWindow(hwnd);
}

unsafe {
    ShowWindow(hwnd, SW_HIDE);
}
```

### 終了（Close）

- `Quit` を受けたら `ctx.send_viewport_cmd(egui::ViewportCommand::Close)` を送る案。

例:

```rust
ctx.send_viewport_cmd(egui::ViewportCommand::Close);
```

補足:
44

- `Close` は「ウィンドウを閉じる」指示。
- バックグラウンドスレッド等がある場合は、別途 graceful shutdown（終了フラグ・Join 等）が必要になり得る。

## 起動時の組み込み（startup/main 側）

- トレイを生成して `TaskTray` と `Receiver` を `LauncherApp::new(...)` に渡し、`LauncherApp` がトレイを保持する。
- ログ初期化は `main` で `env_logger::init()` を実行する。

## 関連コード断片（既存）

- `LauncherApp` は `raw_window_handle` から `HWND` を取得して `hotkey` 登録を行う流れがある。
- `startup.rs` は `eframe::run_native(...)` で `LauncherApp::new(settings, hotkey)` を生成している。

## 実装上の論点

- `eframe` のバージョン差により、ウィンドウ取得 API（`frame.window_handle()` 等）の扱いが変わる可能性がある。
- トレイイベントは UI スレッドを塞がないよう、スレッドで受けて `mpsc` で UI 側へ渡す。
- アイコンのパスは `include_bytes!("../../assets/tray.png")` のように埋め込み前提で設計する（実際の配置に合わせて調整）。

## サンプルコード

### src/ui/task_tray.rs

- トレイ常駐 + メニュー（表示/非表示/終了）
- UI スレッドに負荷をかけないようにスレッドでイベント受信し、`mpsc` でコマンド送信
- `TaskTray` が drop されるとトレイが消えるため、`LauncherApp` 側で保持する

```rust
use std::sync::mpsc;
use std::thread;
use std::time::Duration;

use tray_icon::{
    menu::{Menu, MenuEvent, MenuItem},
    TrayIcon, TrayIconBuilder,
};

#[derive(Debug, Clone, Copy)]
pub enum TrayCommand {
    Show,
    Hide,
    Quit,
}

pub struct TaskTray {
    // drop されるとトレイが消えるので保持する
    _tray: TrayIcon,
    // menu / items もライフタイム維持のため保持する
    _menu: Menu,
    _item_show: MenuItem,
    _item_hide: MenuItem,
    _item_quit: MenuItem,
}

impl TaskTray {
    pub fn new() -> anyhow::Result<(Self, mpsc::Receiver<TrayCommand>)> {
        let (tx, rx) = mpsc::channel::<TrayCommand>();

        let mut menu = Menu::new();

        let item_show = MenuItem::new("表示", true, None);
        let item_hide = MenuItem::new("非表示", true, None);
        let item_quit = MenuItem::new("終了", true, None);
        menu.append_items(&[&item_show, &item_hide, &item_quit])?;

        let show_id = item_show.id().clone();
        let hide_id = item_hide.id().clone();
        let quit_id = item_quit.id().clone();

        let icon = load_tray_icon_from_embedded_png()?;

        let tray = TrayIconBuilder::new()
            .with_tooltip("rs-command-launcher")
            .with_menu(Box::new(menu.clone()))
            .with_icon(icon)
            .build()?;

        let menu_rx = MenuEvent::receiver();

        thread::Builder::new()
            .name("task-tray-event-loop".to_string())
            .spawn(move || {
                loop {
                    if let Ok(event) = menu_rx.try_recv() {
                        let cmd = if event.id == show_id {
                            Some(TrayCommand::Show)
                        } else if event.id == hide_id {
                            Some(TrayCommand::Hide)
                        } else if event.id == quit_id {
                            Some(TrayCommand::Quit)
                        } else {
                            None
                        };

                        if let Some(cmd) = cmd {
                            // 受信側が落ちたら終了
                            if tx.send(cmd).is_err() {
                                break;
                            }
                        }
                    }

                    // ビジーループ回避
                    thread::sleep(Duration::from_millis(16));
                }
            })?;

        Ok((
            Self {
                _tray: tray,
                _menu: menu,
                _item_show: item_show,
                _item_hide: item_hide,
                _item_quit: item_quit,
            },
            rx,
        ))
    }
}

fn load_tray_icon_from_embedded_png() -> anyhow::Result<icon::Icon> {
    // 推奨: 32x32 透過PNG
    // 例: e:\dev\rs-command-launcher\assets\tray.png を用意
    let bytes: &[u8] = include_bytes!("../../assets/tray.png");

    let img = image::load_from_memory(bytes)?.into_rgba8();
    let (w, h) = img.dimensions();
    let rgba = img.into_raw();

    Ok(icon::Icon::from_rgba(rgba, w, h)?)
}
```

### src/ui/startup.rs

- `TaskTray::new()` でトレイを生成
- `TaskTray` と `Receiver<TrayCommand>` を `LauncherApp` に渡し、`LauncherApp` 側で保持する

```rust
use eframe::egui;
use log::info;

use crate::config::Settings;

use super::app::LauncherApp;
use super::hotkey::HotkeyToggle;
use super::task_tray::TaskTray;

const FONT: &[u8] = include_bytes!(r"C:/Windows/Fonts/MEIRYO.TTC");

pub fn startup(settings: Settings) -> anyhow::Result<()> {
    let native_options = eframe::NativeOptions::default();

    // ホットキースレッドの起動
    let hotkey: Option<HotkeyToggle> = None;

    // トレイ生成
    let (tray, tray_rx) = TaskTray::new()?;

    info!("UI を起動します");

    eframe::run_native(
        "command-launcher",
        native_options,
        Box::new(|cc| {
            initialize(&cc.egui_ctx);
            Ok(Box::new(LauncherApp::new(settings, hotkey, tray, tray_rx)?))
        }),
    )
    .map_err(|e| anyhow::Error::msg(format!("UI を起動できません: {e:?}")))?;

    info!("UI を終了しました");
    Ok(())
}

fn initialize(ctx: &egui::Context) {
    configure_fonts(ctx);
}

fn configure_fonts(ctx: &egui::Context) {
    let mut fonts = egui::FontDefinitions::default();

    fonts
        .font_data
        .insert("jp".to_owned(), egui::FontData::from_static(FONT).into());

    fonts
        .families
        .entry(egui::FontFamily::Proportional)
        .or_default()
        .insert(0, "jp".to_owned());

    fonts
        .families
        .entry(egui::FontFamily::Monospace)
        .or_default()
        .insert(0, "jp".to_owned());

    ctx.set_fonts(fonts);
}
```

### src/ui/app.rs

- `LauncherApp` が `TaskTray` を保持する（drop でトレイが消えるのを防ぐ）
- `update()` 冒頭で `tray_rx.try_recv()` を回して、表示/非表示/終了を即時反映
- 表示/非表示は Win32 の `ShowWindow`、終了は `egui::ViewportCommand::Close`

```rust
use std::sync::mpsc;

use eframe::egui;
use log::{debug, error, info};
use raw_window_handle::{HasWindowHandle, RawWindowHandle};
use windows_sys::Win32::Foundation::HWND;
use windows_sys::Win32::UI::WindowsAndMessaging::{
    SetForegroundWindow, ShowWindow, SW_HIDE, SW_SHOW,
};

use crate::config::Settings;
use crate::model::commands;
use crate::runner;

use super::hotkey::HotkeyToggle;
use super::task_tray::{TaskTray, TrayCommand};

#[derive(PartialEq)]
enum InitState {
    Start,
    Ready,
}

pub struct LauncherApp {
    state: InitState,
    command_input: String,
    commands: commands::Commands,
    hwnd: Option<HWND>,
    hotkey: Option<HotkeyToggle>,

    // 追加
    _tray: TaskTray,
    tray_rx: mpsc::Receiver<TrayCommand>,
}

impl LauncherApp {
    pub fn new(
        settings: Settings,
        hotkey: Option<HotkeyToggle>,
        tray: TaskTray,
        tray_rx: mpsc::Receiver<TrayCommand>,
    ) -> anyhow::Result<Self> {
        let commands = settings.commands();
        Ok(Self {
            state: InitState::Start,
            command_input: String::new(),
            commands,
            hwnd: None,
            hotkey,
            _tray: tray,
            tray_rx,
        })
    }

    fn ensure_hwnd(&mut self, frame: &mut eframe::Frame) {
        if self.hwnd.is_some() {
            return;
        }

        if let Ok(handle) = frame.window_handle() {
            if let RawWindowHandle::Win32(h) = handle.as_raw() {
                self.hwnd = Some(h.hwnd.get());
            }
        }
    }

    fn show_window(&self) {
        let Some(hwnd) = self.hwnd else {
            error!("show_window: HWND が未設定です");
            return;
        };
        unsafe {
            ShowWindow(hwnd, SW_SHOW);
            SetForegroundWindow(hwnd);
        }
    }

    fn hide_window(&self) {
        let Some(hwnd) = self.hwnd else {
            error!("hide_window: HWND が未設定です");
            return;
        };
        unsafe {
            ShowWindow(hwnd, SW_HIDE);
        }
    }

    fn process_tray_commands(&mut self, ctx: &egui::Context, frame: &mut eframe::Frame) {
        if self.hwnd.is_none() {
            self.ensure_hwnd(frame);
        }

        while let Ok(cmd) = self.tray_rx.try_recv() {
            match cmd {
                TrayCommand::Show => {
                    info!("tray: show");
                    self.show_window();
                }
                TrayCommand::Hide => {
                    info!("tray: hide");
                    self.hide_window();
                }
                TrayCommand::Quit => {
                    info!("tray: quit");
                    ctx.send_viewport_cmd(egui::ViewportCommand::Close);
                }
            }
        }
    }
}

impl eframe::App for LauncherApp {
    fn update(&mut self, ctx: &egui::Context, frame: &mut eframe::Frame) {
        // 先にトレイ操作を反映
        self.process_tray_commands(ctx, frame);

        // 初期化
        if self.state == InitState::Start {
            debug!("LauncherApp: 初期化処理を開始します");
            self.ensure_hwnd(frame);
            // hotkey 登録など、既存の初期化処理をここに
            self.state = InitState::Ready;
            debug!("LauncherApp: 初期化処理が完了しました");
        }

        egui::CentralPanel::default().show(ctx, |ui| {
            ui.label("launcher");
        });
    }
}
```
